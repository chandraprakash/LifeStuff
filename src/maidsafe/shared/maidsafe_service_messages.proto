// Maidsafe rpc arguments and responses
// data_type is defined in  maidsafe/maidsafe.h as the enum ValueType
// In comments throughout, where a client is requesting a store to a vault, the
// requester provides the pmid of (one of) his vault(s) - known as "client's
// PMID" and the recipient's is known as "vault's PMID".

import "maidsafe/shared/packet.proto";
import "maidsafe/shared/sync_data.proto";

package maidsafe;

message SignedSize {
  required uint64 data_size = 1;
  required bytes signature = 2;  // data_size (as a string) signed
  required bytes pmid = 3;  // client's or Chunk Info holder's PMID (for Store
                            // Chunk or DeleteChunk respectively)
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
}

message StoreContract {
  message InnerContract {
    required uint32 result = 1;  // whether the vault will store the chunk
    required SignedSize signed_size = 2;
  }
  required InnerContract inner_contract = 1;
  required bytes signature = 2;  // Signature of serialised inner_contract
  required bytes pmid = 3;  // vault's PMID
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
}

message StorePrepRequest {
  required bytes chunkname = 1;
  required SignedSize signed_size = 2;
  required bytes request_signature = 3;
}

message StorePrepResponse {
  required StoreContract store_contract = 1;
  required bytes response_signature = 2;  // serialised store_contract signed
                                          // with vault's PMID
}

message StoreChunkRequest {
  required bytes chunkname = 1;
  required bytes data = 2;
  required bytes pmid = 3;  // client's PMID
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
  required bytes request_signature = 6;
  required int32 data_type = 7;
  optional uint32 offset = 8;
  optional uint32 chunklet_size = 9;
}

message StoreChunkResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;  // vault's PMID
}

message AddToWatchListRequest {
  required bytes chunkname = 1;
  required SignedSize signed_size = 2;
  required bytes request_signature = 3;  // Signed using client's PMID key (PMID
                                         // details included in signed_size
}

message AddToWatchListResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;  // Chunk Info holder's PMID
  optional uint32 upload_count = 3;
  optional uint64 total_payment = 4;
}

message RemoveFromWatchListRequest {
  required bytes chunkname = 1;
  required bytes pmid = 2;  // client's PMID
  required bytes public_key = 3;
  required bytes public_key_signature = 4;
  required bytes request_signature = 5;
}

message RemoveFromWatchListResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;  // Chunk Info holder's PMID
}

message AddToReferenceListRequest {
  required bytes chunkname = 1;
  required StoreContract store_contract = 2;
  required bytes request_signature = 3;  // Signed using vault's PMID key (PMID
                                         // details included in store_contract)
}

message AddToReferenceListResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;
}

message GetChunkReferencesRequest {
  required bytes chunkname = 1;
}

message GetChunkReferencesResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;
  repeated bytes references = 3;
}

message AmendAccountRequest {
  enum Amendment {
    kSpaceOffered = 0;  // total (used & unused) vault space available to net
    kSpaceGivenInc = 1;  // called when vault stores a chunk for someone
    kSpaceGivenDec = 2;  // called when vault deletes a chunk
    kSpaceTakenInc = 3;  // called when client uploads a chunk to net
    kSpaceTakenDec = 4;  // called when client deletes a chunk he's previously
                         // uploaded
  }
  required Amendment amendment_type = 1;
  required bytes account_pmid = 2;  // PMID of account to be amended
  required SignedSize signed_size = 3;
  optional bytes chunkname = 4;  // required if type is not kSpaceOffered to
                                 // assert that sender is valid ChunkInfo holder
}

message AmendAccountResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;  // account holder's PMID
}

message ExpectAmendmentRequest {
  required AmendAccountRequest.Amendment amendment_type = 1;
  required bytes chunkname = 2;
  required bytes account_pmid = 3;  // PMID of account owner (i.e. sender)
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
  required bytes request_signature = 6;
  repeated bytes amender_pmids = 7;  // the K vaults to expect amendments from
}

message ExpectAmendmentResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;
}

message AccountStatusRequest {
  required bytes account_pmid = 1;  // PMID of account being queried
  optional uint64 space_requested = 2;
  optional bytes public_key = 3;
  optional bytes public_key_signature = 4;
  optional bytes request_signature = 5;
}

message AccountStatusResponse {
  message AmendmentResult {
    required AmendAccountRequest.Amendment amendment_type = 1;
    required bytes chunkname = 2;
    required uint32 result = 3;
  }
  required uint32 result = 1;
  required bytes pmid = 2;
  optional uint64 space_offered = 3;
  optional uint64 space_given = 4;
  optional uint64 space_taken = 5;
  repeated AmendmentResult amendment_results = 6;
}

message CheckChunkRequest {
  required bytes chunkname = 1;
}

message CheckChunkResponse {
  required uint32 result = 1;
  required bytes pmid = 2;
}

message GetChunkRequest {
  required bytes chunkname = 1;
  optional bytes serialised_cacher_contact = 2;
}

message GetChunkResponse {
  required uint32 result = 1;
  optional bytes content = 2;
  optional bytes pmid = 3;
}

message DeleteChunkRequest {
  required bytes chunkname = 1;
  required SignedSize signed_size = 2;
  required bytes request_signature = 3;  // signed by Chunk Info holder's PMID
  required int32 data_type = 4;
}

message DeleteChunkResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;
}

message ValidityCheckRequest {
  required bytes chunkname = 1;
  required bytes random_data = 2;
}

message ValidityCheckResponse {
  required uint32 result = 1;
  optional bytes hash_content = 2;
  required bytes pmid = 3;
}

message SwapChunkRequest {
  required int32 request_type = 1;
  required bytes chunkname1 = 2;
  optional bytes chunkcontent1 = 3;
  optional int32 size1 = 4;
  optional bytes chunkname2 = 5;
}

message SwapChunkResponse {
  required int32 request_type = 1;
  required uint32 result = 2;
  optional bytes chunkname1 = 3;
  optional bytes chunkcontent1 = 4;
  optional int32 size1 = 5;
  optional bytes chunkname2 = 6;
  optional bytes chunkcontent2 = 7;
  optional int32 size2 = 8;
  required bytes pmid = 9;
}

message CacheChunkRequest {
  required bytes chunkname = 1;
  required bytes chunkcontent = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
  required bytes request_signature = 6;
}

message CacheChunkResponse {
  required uint32 result = 1;
}

message GetSyncDataRequest {
  required bytes pmid = 1;
  required bytes public_key = 2;
  required bytes public_key_signature = 3;
  required bytes request_signature = 4;
}

message GetSyncDataResponse {
  required uint32 result = 1;
  optional maidsafe.vault.VaultAccountSet vault_account_set = 2;
  optional maidsafe.vault.ChunkInfoMap chunk_info_map = 3;
  optional maidsafe.vault.VaultBufferPacketMap vault_buffer_packet_map = 4;
}

message GetAccountRequest {
  required bytes account_pmid = 1;  // PMID of account being queried
  required bytes pmid = 2;
  required bytes public_key = 3;
  required bytes public_key_signature = 4;
  required bytes request_signature = 5;
}

message GetAccountResponse {
  required uint32 result = 1;
  optional maidsafe.vault.VaultAccountSet.VaultAccount vault_account = 2;
}

message GetChunkInfoRequest {
  required bytes chunkname = 1;
  required bytes pmid = 2;
  required bytes public_key = 3;
  required bytes public_key_signature = 4;
  required bytes request_signature = 5;
}

message GetChunkInfoResponse {
  required uint32 result = 1;
  optional maidsafe.vault.ChunkInfoMap.VaultChunkInfo vault_chunk_info = 2;
}

message GetBufferPacketRequest {
  required bytes bufferpacket_name = 1;
  required bytes pmid = 2;
  required bytes public_key = 3;
  required bytes public_key_signature = 4;
  required bytes request_signature = 5;
}

message GetBufferPacketResponse {
  required uint32 result = 1;
  optional maidsafe.vault.VaultBufferPacketMap.VaultBufferPacket vault_buffer_packet = 2;
}

enum OwnLocalVaultResult {
  OWNED_SUCCESS = 0;
  VAULT_ALREADY_OWNED = 1;
  VAULT_IS_DOWN = 2;
  INVALID_RSA_KEYS = 3;
  NOT_ENOUGH_SPACE = 4;
  NO_SPACE_ALLOCATED = 5;
  INVALID_PORT = 6;
  FAILED_TO_START_VAULT = 7;
  INVALID_OWNREQUEST = 8;
  INVALID_PMID_NAME = 9;
}

message SetLocalVaultOwnedRequest {
  required bytes public_key = 1;
  required bytes private_key = 2;
  required bytes signed_public_key = 3;
  required bytes vault_dir = 4;
  required uint32 port = 5;
  required uint64 space = 6;
}

message SetLocalVaultOwnedResponse {
  required OwnLocalVaultResult result = 1;
  optional bytes pmid_name = 2;
}

enum VaultOwnershipStatus {
  NOT_OWNED = 0;
  OWNED = 1;
  DOWN = 2;
  ISOWNRPC_CANCELLED = 3;
}

message LocalVaultOwnedRequest {}

message LocalVaultOwnedResponse {
  required VaultOwnershipStatus status = 1;
}

// Buffer Packet Ops

message CreateBPRequest {
  required bytes bufferpacket_name = 1;
  required bytes data = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes signed_public_key = 5;
  required bytes signed_request = 6;
}

message CreateBPResponse {
  required uint32 result = 1;
  optional bytes pmid_id = 2;
  optional bytes public_key = 3;
  optional bytes signed_public_key = 4;
}

message ModifyBPInfoRequest {
  required bytes bufferpacket_name = 1;
  required bytes data = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes signed_public_key = 5;
  required bytes signed_request = 6;
}

message ModifyBPInfoResponse {
  required uint32 result = 1;
  optional bytes pmid_id = 2;
  optional bytes public_key = 3;
  optional bytes signed_public_key = 4;
}

message GetBPMessagesRequest {
  required bytes bufferpacket_name = 1;
  required bytes public_key = 2;
  required bytes pmid = 3;
  required bytes signed_public_key = 4;
  required bytes signed_request = 5;
}

message GetBPMessagesResponse {
  required uint32 result = 1;
  repeated bytes messages = 2;
  optional bytes pmid_id = 3;
  optional bytes public_key = 4;
  optional bytes signed_public_key = 5;
}

message AddBPMessageRequest {
  required bytes bufferpacket_name = 1;
  required bytes data = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes signed_public_key = 5;
  required bytes signed_request = 6;
}

message AddBPMessageResponse {
  required uint32 result = 1;
  optional bytes pmid_id = 2;
  optional bytes public_key = 3;
  optional bytes signed_public_key = 4;
}

message GetBPPresenceRequest {
  required bytes bufferpacket_name = 1;
  required bytes public_key = 2;
  required bytes pmid = 3;
  required bytes signed_public_key = 4;
  required bytes signed_request = 5;
}

message GetBPPresenceResponse {
  required uint32 result = 1;
  repeated bytes messages = 2;
  optional bytes pmid_id = 3;
  optional bytes public_key = 4;
  optional bytes signed_public_key = 5;
}

message AddBPPresenceRequest {
  required bytes bufferpacket_name = 1;
  required bytes data = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes signed_public_key = 5;
  required bytes signed_request = 6;
}

message AddBPPresenceResponse {
  required uint32 result = 1;
  optional bytes pmid_id = 2;
  optional bytes public_key = 3;
  optional bytes signed_public_key = 4;
}
